name: Bot Activity Monitoring

on:
  schedule:
    # Run daily at 00:00 UTC (09:00 JST)
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (no alerts)'
        required: false
        default: false
        type: boolean

permissions: {}

concurrency:
  group: bot-monitoring
  cancel-in-progress: false

env:
  # Days of PR history to check
  PR_LOOKBACK_DAYS: 30

jobs:
  monitor:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Check bot activity
        id: check
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const EXPECTED_BOTS = [
              // Priority: High - Quality assurance critical
              {
                name: 'qodo-code-review[bot]',
                activityType: 'pr_comment',
                maxSilentDays: 7,
                requirePrActivity: true
              },
              {
                name: 'sonarqubecloud[bot]',
                activityType: 'check_run',
                maxSilentDays: 7,
                requirePrActivity: true
              },
              {
                name: 'codecov-commenter',
                activityType: 'pr_comment',
                maxSilentDays: 14,
                requirePrActivity: true
              },
              {
                name: 'dependabot[bot]',
                activityType: 'pr_create',
                maxSilentDays: 30,
                requirePrActivity: false
              },
              {
                name: 'renovate[bot]',
                activityType: 'pr_create',
                maxSilentDays: 30,
                requirePrActivity: false
              },
              // Priority: Medium - Alternatives available
              {
                name: 'mend-bolt-for-github[bot]',
                activityType: 'check_run',
                maxSilentDays: 14,
                requirePrActivity: true
              },
              {
                name: 'pre-commit-ci[bot]',
                activityType: 'commit_status',
                maxSilentDays: 14,
                requirePrActivity: true
              },
              {
                name: 'snyk-bot',
                activityType: 'check_run',
                maxSilentDays: 14,
                requirePrActivity: true,
                note: 'Currently stopped due to free tier limits. Expected to resume in February.'
              },
              {
                name: 'cursor[bot]',
                activityType: 'pr_comment',
                maxSilentDays: 14,
                requirePrActivity: true,
                note: 'Bugbot feature. Currently stopped due to free tier limits. Resets February 1st.'
              },
              {
                name: 'restyled-io[bot]',
                activityType: 'pr_comment',
                maxSilentDays: 14,
                requirePrActivity: true
              },
              // Priority: Low - Limited impact
              {
                name: 'imgbot[bot]',
                activityType: 'pr_create',
                maxSilentDays: 60,
                requirePrActivity: false
              }
              // Note: allcontributors[bot] excluded - trigger-based (only responds to @all-contributors commands)
            ];

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const now = new Date();
            const lookbackDate = new Date(now.getTime() - (parseInt(process.env.PR_LOOKBACK_DAYS) * 24 * 60 * 60 * 1000));

            console.log(`Checking bot activity since ${lookbackDate.toISOString()}`);
            console.log(`Repository: ${owner}/${repo}`);
            console.log('');

            // Get recent PRs
            const prs = await github.rest.pulls.list({
              owner,
              repo,
              state: 'all',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });

            const recentPrs = prs.data.filter(pr => new Date(pr.updated_at) >= lookbackDate);
            const hasPrActivity = recentPrs.length > 0;
            const lastPrDate = recentPrs.length > 0 ? new Date(recentPrs[0].updated_at) : null;

            console.log(`Found ${recentPrs.length} PRs updated since ${lookbackDate.toISOString()}`);
            if (lastPrDate) {
              console.log(`Last PR activity: ${lastPrDate.toISOString()}`);
            }
            console.log('');

            // Track bot activity
            const botActivity = {};
            for (const bot of EXPECTED_BOTS) {
              botActivity[bot.name] = {
                lastSeen: null,
                config: bot
              };
            }

            // Check PR comments (both issue comments and review comments)
            // Limit to 30 PRs to avoid rate limits
            for (const pr of recentPrs.slice(0, 30)) {
              // Issue comments (general PR comments)
              const issueComments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: pr.number,
                per_page: 100
              });

              for (const comment of issueComments.data) {
                const author = comment.user?.login;
                if (author && botActivity[author]) {
                  const commentDate = new Date(comment.created_at);
                  if (!botActivity[author].lastSeen || commentDate > botActivity[author].lastSeen) {
                    botActivity[author].lastSeen = commentDate;
                  }
                }
              }

              // Review comments (inline code comments)
              try {
                const reviewComments = await github.rest.pulls.listReviewComments({
                  owner,
                  repo,
                  pull_number: pr.number,
                  per_page: 100
                });

                for (const comment of reviewComments.data) {
                  const author = comment.user?.login;
                  if (author && botActivity[author]) {
                    const commentDate = new Date(comment.created_at);
                    if (!botActivity[author].lastSeen || commentDate > botActivity[author].lastSeen) {
                      botActivity[author].lastSeen = commentDate;
                    }
                  }
                }
              } catch (e) {
                console.log(`Warning: Could not fetch review comments for PR #${pr.number}: ${e.message}`);
              }
            }

            // Check PR creators (for bots that create PRs)
            for (const pr of recentPrs) {
              const author = pr.user?.login;
              if (author && botActivity[author]) {
                const prDate = new Date(pr.created_at);
                if (!botActivity[author].lastSeen || prDate > botActivity[author].lastSeen) {
                  botActivity[author].lastSeen = prDate;
                }
              }
            }

            // Check check runs (for bots that run checks)
            for (const pr of recentPrs.slice(0, 20)) {  // Limit to avoid rate limits
              try {
                const checkRuns = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: pr.head.sha,
                  per_page: 100
                });

                for (const checkRun of checkRuns.data.check_runs) {
                  // Check run app name often doesn't include [bot] suffix
                  const appName = checkRun.app?.slug?.toLowerCase() || '';
                  const appOwner = checkRun.app?.owner?.login?.toLowerCase() || '';

                  for (const botName in botActivity) {
                    if (botActivity[botName].config.activityType === 'check_run') {
                      // Match by app slug (e.g., "sonarcloud" matches "sonarqubecloud[bot]")
                      // Also handle bots without [bot] suffix (e.g., "snyk-bot")
                      const normalizedBotName = botName.replace('[bot]', '').replace('-bot', '').toLowerCase();
                      const matchesApp = appName && (
                        appName.includes(normalizedBotName) ||
                        normalizedBotName.includes(appName) ||
                        appOwner.includes(normalizedBotName)
                      );

                      if (matchesApp) {
                        const checkDate = new Date(checkRun.completed_at || checkRun.started_at);
                        if (!botActivity[botName].lastSeen || checkDate > botActivity[botName].lastSeen) {
                          botActivity[botName].lastSeen = checkDate;
                        }
                      }
                    }
                  }
                }
              } catch (e) {
                console.log(`Warning: Could not fetch check runs for PR #${pr.number}: ${e.message}`);
              }

              // Check commit statuses (for bots that use legacy status API like pre-commit-ci)
              try {
                const statuses = await github.rest.repos.listCommitStatusesForRef({
                  owner,
                  repo,
                  ref: pr.head.sha,
                  per_page: 100
                });

                for (const status of statuses.data) {
                  const creator = status.creator?.login;
                  if (creator && botActivity[creator] && botActivity[creator].config.activityType === 'commit_status') {
                    const statusDate = new Date(status.created_at);
                    if (!botActivity[creator].lastSeen || statusDate > botActivity[creator].lastSeen) {
                      botActivity[creator].lastSeen = statusDate;
                    }
                  }
                }
              } catch (e) {
                console.log(`Warning: Could not fetch commit statuses for PR #${pr.number}: ${e.message}`);
              }
            }

            // Analyze results
            const silentBots = [];
            const activeBots = [];
            const skippedBots = [];

            for (const [botName, data] of Object.entries(botActivity)) {
              const config = data.config;
              const lastSeen = data.lastSeen;

              // Skip if no PR activity and bot requires it
              if (config.requirePrActivity && !hasPrActivity) {
                skippedBots.push({
                  name: botName,
                  reason: 'No PR activity in lookback period'
                });
                continue;
              }

              if (!lastSeen) {
                // Never seen
                silentBots.push({
                  name: botName,
                  lastSeen: null,
                  silentDays: null,
                  maxSilentDays: config.maxSilentDays,
                  message: 'Never seen in lookback period'
                });
              } else {
                const silentDays = Math.floor((now - lastSeen) / (24 * 60 * 60 * 1000));

                if (silentDays > config.maxSilentDays) {
                  silentBots.push({
                    name: botName,
                    lastSeen: lastSeen.toISOString(),
                    silentDays,
                    maxSilentDays: config.maxSilentDays,
                    message: `Silent for ${silentDays} days (threshold: ${config.maxSilentDays})`
                  });
                } else {
                  activeBots.push({
                    name: botName,
                    lastSeen: lastSeen.toISOString(),
                    silentDays
                  });
                }
              }
            }

            // Output results
            console.log('=== Bot Activity Report ===');
            console.log('');

            console.log('Active bots:');
            for (const bot of activeBots) {
              console.log(`  ‚úÖ ${bot.name}: last seen ${bot.silentDays} days ago`);
            }
            console.log('');

            console.log('Skipped bots (no PR activity):');
            for (const bot of skippedBots) {
              console.log(`  ‚è≠Ô∏è ${bot.name}: ${bot.reason}`);
            }
            console.log('');

            console.log('Silent bots:');
            for (const bot of silentBots) {
              console.log(`  ‚ö†Ô∏è ${bot.name}: ${bot.message}`);
            }
            console.log('');

            // Set outputs
            core.setOutput('silent_bots', JSON.stringify(silentBots));
            core.setOutput('has_silent_bots', silentBots.length > 0);
            core.setOutput('report', JSON.stringify({
              timestamp: now.toISOString(),
              repository: `${owner}/${repo}`,
              prCount: recentPrs.length,
              activeBots,
              skippedBots,
              silentBots
            }));

            return silentBots;

      - name: Write job summary
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          REPORT_JSON: ${{ steps.check.outputs.report }}
        with:
          script: |
            const report = JSON.parse(process.env.REPORT_JSON);

            let summary = `## Bot Activity Report\n\n`;
            summary += `**Repository:** ${report.repository}\n`;
            summary += `**Checked at:** ${report.timestamp}\n`;
            summary += `**PRs analyzed:** ${report.prCount}\n\n`;

            if (report.activeBots.length > 0) {
              summary += `### ‚úÖ Active Bots (${report.activeBots.length})\n\n`;
              summary += `| Bot | Last Seen | Days Ago |\n`;
              summary += `|-----|-----------|----------|\n`;
              for (const bot of report.activeBots) {
                summary += `| ${bot.name} | ${bot.lastSeen.split('T')[0]} | ${bot.silentDays} |\n`;
              }
              summary += `\n`;
            }

            if (report.skippedBots.length > 0) {
              summary += `### ‚è≠Ô∏è Skipped Bots (${report.skippedBots.length})\n\n`;
              for (const bot of report.skippedBots) {
                summary += `- **${bot.name}**: ${bot.reason}\n`;
              }
              summary += `\n`;
            }

            if (report.silentBots.length > 0) {
              summary += `### ‚ö†Ô∏è Silent Bots (${report.silentBots.length})\n\n`;
              summary += `| Bot | Last Seen | Silent Days | Threshold |\n`;
              summary += `|-----|-----------|-------------|----------|\n`;
              for (const bot of report.silentBots) {
                const lastSeen = bot.lastSeen ? bot.lastSeen.split('T')[0] : 'Never';
                const silentDays = bot.silentDays ?? 'N/A';
                summary += `| ${bot.name} | ${lastSeen} | ${silentDays} | ${bot.maxSilentDays} |\n`;
              }
              summary += `\n`;
            } else {
              summary += `### üéâ All monitored bots are active!\n\n`;
            }

            await core.summary.addRaw(summary).write();

      - name: Send Slack notification
        if: steps.check.outputs.has_silent_bots == 'true' && inputs.dry_run != true
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SILENT_BOTS_JSON: ${{ steps.check.outputs.silent_bots }}
        run: |
          if [ -z "$SLACK_WEBHOOK" ]; then
            echo "SLACK_WEBHOOK secret not configured, skipping Slack notification"
            exit 0
          fi

          BOT_NAMES=$(echo "$SILENT_BOTS_JSON" | jq -r '.[].name' | tr '\n' ', ' | sed 's/,$//')

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"‚ö†Ô∏è *Bot Activity Alert*\n\nSilent bots detected in ${{ github.repository }}:\n‚Ä¢ ${BOT_NAMES}\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>\"
            }" \
            "$SLACK_WEBHOOK"
