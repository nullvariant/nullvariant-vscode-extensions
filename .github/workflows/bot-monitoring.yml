name: Bot Activity Monitoring

on:
  schedule:
    # Run daily at 00:00 UTC (09:00 JST)
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (no alerts)'
        required: false
        default: false
        type: boolean

permissions: {}

concurrency:
  group: bot-monitoring
  cancel-in-progress: false

env:
  # Days of PR history to check
  PR_LOOKBACK_DAYS: 30

jobs:
  monitor:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: read

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Check bot activity
        id: check
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const EXPECTED_BOTS = [
              // Priority: High - Quality assurance critical
              {
                name: 'qodo-code-review[bot]',
                activityType: 'pr_comment',
                maxSilentDays: 7,
                requirePrActivity: true
              },
              {
                name: 'sonarqubecloud[bot]',
                activityType: 'check_run',
                maxSilentDays: 7,
                requirePrActivity: true
              },
              {
                name: 'codecov[bot]',
                activityType: 'pr_comment',
                maxSilentDays: 14,
                requirePrActivity: true
              },
              {
                name: 'dependabot[bot]',
                activityType: 'pr_create',
                maxSilentDays: 30,
                requirePrActivity: false
              },
              {
                name: 'renovate[bot]',
                activityType: 'pr_create',
                maxSilentDays: 30,
                requirePrActivity: false
              },
              // Priority: Medium - Alternatives available
              {
                name: 'mend-bolt-for-github[bot]',
                activityType: 'check_run',
                maxSilentDays: 14,
                requirePrActivity: true
              },
              {
                name: 'pre-commit-ci[bot]',
                activityType: 'check_run',
                maxSilentDays: 14,
                requirePrActivity: true
              },
              {
                name: 'snyk-bot',
                activityType: 'check_run',
                maxSilentDays: 14,
                requirePrActivity: true,
                note: 'Currently stopped due to free tier limits. Expected to resume in February.'
              },
              {
                name: 'cursor[bot]',
                activityType: 'pr_comment',
                maxSilentDays: 14,
                requirePrActivity: true,
                note: 'Bugbot feature. Currently stopped due to free tier limits. Resets February 1st.'
              },
              {
                name: 'restyled-io[bot]',
                activityType: 'pr_comment',
                maxSilentDays: 14,
                requirePrActivity: true
              },
              // Priority: Low - Limited impact
              {
                name: 'imgbot[bot]',
                activityType: 'pr_create',
                maxSilentDays: 60,
                requirePrActivity: false
              },
              {
                name: 'allcontributors[bot]',
                activityType: 'pr_comment',
                maxSilentDays: 60,
                requirePrActivity: true
              }
            ];

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const now = new Date();
            const lookbackDate = new Date(now.getTime() - (parseInt(process.env.PR_LOOKBACK_DAYS) * 24 * 60 * 60 * 1000));

            console.log(`Checking bot activity since ${lookbackDate.toISOString()}`);
            console.log(`Repository: ${owner}/${repo}`);
            console.log('');

            // Get recent PRs
            const prs = await github.rest.pulls.list({
              owner,
              repo,
              state: 'all',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });

            const recentPrs = prs.data.filter(pr => new Date(pr.updated_at) >= lookbackDate);
            const hasPrActivity = recentPrs.length > 0;
            const lastPrDate = recentPrs.length > 0 ? new Date(recentPrs[0].updated_at) : null;

            console.log(`Found ${recentPrs.length} PRs updated since ${lookbackDate.toISOString()}`);
            if (lastPrDate) {
              console.log(`Last PR activity: ${lastPrDate.toISOString()}`);
            }
            console.log('');

            // Track bot activity
            const botActivity = {};
            for (const bot of EXPECTED_BOTS) {
              botActivity[bot.name] = {
                lastSeen: null,
                config: bot
              };
            }

            // Check PR comments (both issue comments and review comments)
            // Limit to 30 PRs to avoid rate limits
            for (const pr of recentPrs.slice(0, 30)) {
              // Issue comments (general PR comments)
              const issueComments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: pr.number,
                per_page: 100
              });

              for (const comment of issueComments.data) {
                const author = comment.user?.login;
                if (author && botActivity[author]) {
                  const commentDate = new Date(comment.created_at);
                  if (!botActivity[author].lastSeen || commentDate > botActivity[author].lastSeen) {
                    botActivity[author].lastSeen = commentDate;
                  }
                }
              }

              // Review comments (inline code comments)
              try {
                const reviewComments = await github.rest.pulls.listReviewComments({
                  owner,
                  repo,
                  pull_number: pr.number,
                  per_page: 100
                });

                for (const comment of reviewComments.data) {
                  const author = comment.user?.login;
                  if (author && botActivity[author]) {
                    const commentDate = new Date(comment.created_at);
                    if (!botActivity[author].lastSeen || commentDate > botActivity[author].lastSeen) {
                      botActivity[author].lastSeen = commentDate;
                    }
                  }
                }
              } catch (e) {
                console.log(`Warning: Could not fetch review comments for PR #${pr.number}: ${e.message}`);
              }
            }

            // Check PR creators (for bots that create PRs)
            for (const pr of recentPrs) {
              const author = pr.user?.login;
              if (author && botActivity[author]) {
                const prDate = new Date(pr.created_at);
                if (!botActivity[author].lastSeen || prDate > botActivity[author].lastSeen) {
                  botActivity[author].lastSeen = prDate;
                }
              }
            }

            // Check check runs (for bots that run checks)
            for (const pr of recentPrs.slice(0, 20)) {  // Limit to avoid rate limits
              try {
                const checkRuns = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: pr.head.sha,
                  per_page: 100
                });

                for (const checkRun of checkRuns.data.check_runs) {
                  // Check run app name often doesn't include [bot] suffix
                  const appName = checkRun.app?.slug?.toLowerCase() || '';
                  const appOwner = checkRun.app?.owner?.login?.toLowerCase() || '';

                  for (const botName in botActivity) {
                    if (botActivity[botName].config.activityType === 'check_run') {
                      // Match by app slug (e.g., "sonarcloud" matches "sonarqubecloud[bot]")
                      // Also handle bots without [bot] suffix (e.g., "snyk-bot")
                      const normalizedBotName = botName.replace('[bot]', '').replace('-bot', '').toLowerCase();
                      const matchesApp = appName && (
                        appName.includes(normalizedBotName) ||
                        normalizedBotName.includes(appName) ||
                        appOwner.includes(normalizedBotName)
                      );

                      if (matchesApp) {
                        const checkDate = new Date(checkRun.completed_at || checkRun.started_at);
                        if (!botActivity[botName].lastSeen || checkDate > botActivity[botName].lastSeen) {
                          botActivity[botName].lastSeen = checkDate;
                        }
                      }
                    }
                  }
                }
              } catch (e) {
                console.log(`Warning: Could not fetch check runs for PR #${pr.number}: ${e.message}`);
              }
            }

            // Analyze results
            const silentBots = [];
            const activeBots = [];
            const skippedBots = [];

            for (const [botName, data] of Object.entries(botActivity)) {
              const config = data.config;
              const lastSeen = data.lastSeen;

              // Skip if no PR activity and bot requires it
              if (config.requirePrActivity && !hasPrActivity) {
                skippedBots.push({
                  name: botName,
                  reason: 'No PR activity in lookback period'
                });
                continue;
              }

              if (!lastSeen) {
                // Never seen
                silentBots.push({
                  name: botName,
                  lastSeen: null,
                  silentDays: null,
                  maxSilentDays: config.maxSilentDays,
                  message: 'Never seen in lookback period'
                });
              } else {
                const silentDays = Math.floor((now - lastSeen) / (24 * 60 * 60 * 1000));

                if (silentDays > config.maxSilentDays) {
                  silentBots.push({
                    name: botName,
                    lastSeen: lastSeen.toISOString(),
                    silentDays,
                    maxSilentDays: config.maxSilentDays,
                    message: `Silent for ${silentDays} days (threshold: ${config.maxSilentDays})`
                  });
                } else {
                  activeBots.push({
                    name: botName,
                    lastSeen: lastSeen.toISOString(),
                    silentDays
                  });
                }
              }
            }

            // Output results
            console.log('=== Bot Activity Report ===');
            console.log('');

            console.log('Active bots:');
            for (const bot of activeBots) {
              console.log(`  ‚úÖ ${bot.name}: last seen ${bot.silentDays} days ago`);
            }
            console.log('');

            console.log('Skipped bots (no PR activity):');
            for (const bot of skippedBots) {
              console.log(`  ‚è≠Ô∏è ${bot.name}: ${bot.reason}`);
            }
            console.log('');

            console.log('Silent bots:');
            for (const bot of silentBots) {
              console.log(`  ‚ö†Ô∏è ${bot.name}: ${bot.message}`);
            }
            console.log('');

            // Set outputs
            core.setOutput('silent_bots', JSON.stringify(silentBots));
            core.setOutput('has_silent_bots', silentBots.length > 0);
            core.setOutput('report', JSON.stringify({
              timestamp: now.toISOString(),
              repository: `${owner}/${repo}`,
              prCount: recentPrs.length,
              activeBots,
              skippedBots,
              silentBots
            }));

            return silentBots;

      - name: Write job summary
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          REPORT_JSON: ${{ steps.check.outputs.report }}
        with:
          script: |
            const report = JSON.parse(process.env.REPORT_JSON);

            let summary = `## Bot Activity Report\n\n`;
            summary += `**Repository:** ${report.repository}\n`;
            summary += `**Checked at:** ${report.timestamp}\n`;
            summary += `**PRs analyzed:** ${report.prCount}\n\n`;

            if (report.activeBots.length > 0) {
              summary += `### ‚úÖ Active Bots (${report.activeBots.length})\n\n`;
              summary += `| Bot | Last Seen | Days Ago |\n`;
              summary += `|-----|-----------|----------|\n`;
              for (const bot of report.activeBots) {
                summary += `| ${bot.name} | ${bot.lastSeen.split('T')[0]} | ${bot.silentDays} |\n`;
              }
              summary += `\n`;
            }

            if (report.skippedBots.length > 0) {
              summary += `### ‚è≠Ô∏è Skipped Bots (${report.skippedBots.length})\n\n`;
              for (const bot of report.skippedBots) {
                summary += `- **${bot.name}**: ${bot.reason}\n`;
              }
              summary += `\n`;
            }

            if (report.silentBots.length > 0) {
              summary += `### ‚ö†Ô∏è Silent Bots (${report.silentBots.length})\n\n`;
              summary += `| Bot | Last Seen | Silent Days | Threshold |\n`;
              summary += `|-----|-----------|-------------|----------|\n`;
              for (const bot of report.silentBots) {
                const lastSeen = bot.lastSeen ? bot.lastSeen.split('T')[0] : 'Never';
                const silentDays = bot.silentDays ?? 'N/A';
                summary += `| ${bot.name} | ${lastSeen} | ${silentDays} | ${bot.maxSilentDays} |\n`;
              }
              summary += `\n`;
            } else {
              summary += `### üéâ All monitored bots are active!\n\n`;
            }

            await core.summary.addRaw(summary).write();

      - name: Create alert issue
        if: steps.check.outputs.has_silent_bots == 'true' && inputs.dry_run != true
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          SILENT_BOTS_JSON: ${{ steps.check.outputs.silent_bots }}
        with:
          script: |
            const silentBots = JSON.parse(process.env.SILENT_BOTS_JSON);

            // Check for existing open alert issue
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'bot-monitoring-alert',
              per_page: 10
            });

            if (existingIssues.data.length > 0) {
              // Add comment to existing issue
              const issue = existingIssues.data[0];
              const botList = silentBots.map(b => `- **${b.name}**: ${b.message}`).join('\n');

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## Daily Check Update - ${new Date().toISOString().split('T')[0]}\n\n### Silent Bots Detected\n\n${botList}\n\n---\n*This comment was automatically generated by the bot monitoring workflow.*`
              });

              console.log(`Added comment to existing issue #${issue.number}`);
            } else {
              // Create new issue
              const botList = silentBots.map(b => `- **${b.name}**: ${b.message}`).join('\n');

              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '‚ö†Ô∏è Bot Activity Alert: Silent bots detected',
                body: `## Bot Activity Alert\n\nThe following bots have exceeded their expected activity threshold:\n\n${botList}\n\n### What to check\n\n1. Verify the bot's GitHub App is still installed\n2. Check if authentication has expired\n3. Review the bot's service status page\n4. Check if the bot requires manual re-authorization\n\n### Related\n\n- Issue-00061: GitHub App/Bot Activity Monitoring System\n\n---\n*This issue was automatically created by the bot monitoring workflow.*`,
                labels: ['bot-monitoring-alert']
              });

              console.log(`Created new alert issue #${issue.data.number}`);
            }

      - name: Send Slack notification
        if: steps.check.outputs.has_silent_bots == 'true' && inputs.dry_run != true
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SILENT_BOTS_JSON: ${{ steps.check.outputs.silent_bots }}
        run: |
          if [ -z "$SLACK_WEBHOOK" ]; then
            echo "SLACK_WEBHOOK secret not configured, skipping Slack notification"
            exit 0
          fi

          BOT_NAMES=$(echo "$SILENT_BOTS_JSON" | jq -r '.[].name' | tr '\n' ', ' | sed 's/,$//')

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"‚ö†Ô∏è *Bot Activity Alert*\n\nSilent bots detected in ${{ github.repository }}:\n‚Ä¢ ${BOT_NAMES}\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>\"
            }" \
            "$SLACK_WEBHOOK"
